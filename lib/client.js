// Generated by CoffeeScript 1.4.0
(function() {
  var SocketListener, Task,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Task = require('models/task').Task;

  SocketListener = (function() {

    SocketListener.prototype.models = {};

    SocketListener.prototype.events = [];

    SocketListener.prototype.onRemoteCreation = function(model) {};

    SocketListener.prototype.onRemoteUpdate = function(model, collection) {};

    SocketListener.prototype.onRemoteDelete = function(model, collection) {};

    SocketListener.prototype.shouldBeAdded = function(model, collection) {
      return true;
    };

    function SocketListener() {
      this.processStack = __bind(this.processStack, this);

      this.callbackFactory = __bind(this.callbackFactory, this);

      this.resume = __bind(this.resume, this);

      this.pause = __bind(this.pause, this);
      try {
        this.connect();
      } catch (err) {
        console.log("Error while connecting to socket.io");
        console.log(err.stack);
      }
      this.collections = [];
      this.tmpcollection = new Backbone.Collection();
      this.watch(this.tmpcollection);
      this.stack = [];
      this.ignore = [];
      this.paused = 0;
    }

    SocketListener.prototype.connect = function() {
      var event, pathToSocketIO, socket, url, _i, _len, _ref, _results;
      url = window.location.origin;
      pathToSocketIO = "" + (window.location.pathname.substring(1)) + "socket.io";
      socket = io.connect(url, {
        resource: pathToSocketIO
      });
      _ref = this.events;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        _results.push(socket.on(event, this.callbackFactory(event)));
      }
      return _results;
    };

    SocketListener.prototype.watch = function(collection) {
      this.collections.push(collection);
      collection.on('request', this.pause);
      collection.on('sync', this.resume);
      collection.on('destroy', this.resume);
      return collection.on('error', this.resume);
    };

    SocketListener.prototype.watchOne = function(model) {
      return this.collections[0].add(model);
    };

    SocketListener.prototype.pause = function(model, xhr, options) {
      var Model, doctype, key, operation, _ref;
      if (options.ignoreMySocketNotification) {
        operation = model.isNew() ? 'create' : 'update';
        doctype = null;
        _ref = this.models;
        for (key in _ref) {
          Model = _ref[key];
          if (model instanceof Model) {
            doctype = key;
          }
        }
        if (doctype == null) {
          return;
        }
        this.ignore.push({
          doctype: doctype,
          operation: operation,
          model: model
        });
        return this.paused = this.paused + 1;
      }
    };

    SocketListener.prototype.resume = function(model, resp, options) {
      if (options.ignoreMySocketNotification) {
        this.paused = this.paused - 1;
        if (this.paused <= 0) {
          this.processStack();
          return this.paused = 0;
        }
      }
    };

    SocketListener.prototype.cleanStack = function() {
      var ignoreEvent, ignoreIndex, removed, stackEvent, stackIndex, _results;
      ignoreIndex = 0;
      _results = [];
      while (ignoreIndex < this.ignore.length) {
        removed = false;
        stackIndex = 0;
        ignoreEvent = this.ignore[ignoreIndex];
        while (stackIndex < this.stack.length) {
          stackEvent = this.stack[stackIndex];
          if (stackEvent.operation === ignoreEvent.operation && stackEvent.id === ignoreEvent.model.id) {
            this.stack.splice(stackIndex, 1);
            removed = true;
            break;
          } else {
            stackIndex++;
          }
        }
        if (removed) {
          _results.push(this.ignore.splice(ignoreIndex, 1));
        } else {
          _results.push(ignoreIndex++);
        }
      }
      return _results;
    };

    SocketListener.prototype.callbackFactory = function(event) {
      var _this = this;
      return function(id) {
        var doctype, fullevent, operation, _ref;
        _ref = event.split('.'), doctype = _ref[0], operation = _ref[1];
        fullevent = {
          id: id,
          doctype: doctype,
          operation: operation
        };
        _this.stack.push(fullevent);
        if (_this.paused === 0) {
          return _this.processStack();
        }
      };
    };

    SocketListener.prototype.processStack = function() {
      var _results;
      this.cleanStack();
      _results = [];
      while (this.stack.length > 0) {
        _results.push(this.process(this.stack.shift()));
      }
      return _results;
    };

    SocketListener.prototype.process = function(event) {
      var doctype, id, model, operation,
        _this = this;
      doctype = event.doctype, operation = event.operation, id = event.id;
      switch (operation) {
        case 'create':
          model = new this.models[doctype]({
            id: id
          });
          return model.fetch({
            success: this.onRemoteCreation
          });
        case 'update':
          return this.collections.forEach(function(collection) {
            if (!(model = collection.get(id))) {
              return;
            }
            return model.fetch({
              success: function(fetched) {
                if (fetched.changedAttributes()) {
                  return _this.onRemoteUpdate(fetched, collection);
                }
              }
            });
          });
        case 'delete':
          return this.collections.forEach(function(collection) {
            if (!(model = collection.get(id))) {
              return;
            }
            return this.onRemoteDelete(task, collection);
          });
      }
    };

    return SocketListener;

  })();

  module.exports = SocketListener;

}).call(this);
